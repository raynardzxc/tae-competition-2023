---
title: "TAE Competition 2023"
output: html_notebook
---

# Import Libraries

```{r}
source("usePackages.R")
edapkgnames <- c("tidyverse","tm","wordcloud","dplyr")
loadPkgs(edapkgnames)
```

# Load Data
Provided with twitter sentiment data containing the following columns:
- `tweet`: (character) a string of letters and symbols representing a tweet
- `sentiment`: (integer) an integer representing a sentiment corresponding to a tweet: 1 indicates negative sentiment, 2 indicates neutral, 3 indicates positive

```{r}
twitter_data <- read.csv("../input/train1.csv")
str(twitter_data)
summary(twitter_data)
```
## Check for any missing values
```{r}
sum(is.na(twitter_data))
```

## Check the balance of sentiment categories
Imbalanced Data
A classification data set with skewed class proportions is called imbalanced.
```{r}
table(twitter_data$sentiment)
```

## Word Cloud
```{r}
positive_tweets <- twitter_data %>%
  filter(sentiment == 3) %>%
  select(tweet)

corpus <- Corpus(VectorSource(positive_tweets$tweet))
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removeWords, stopwords("english"))
corpus <- tm_map(corpus, stripWhitespace)

wordcloud(corpus, max.words = 50)
```
```{r}
negative_tweets <- twitter_data %>%
  filter(sentiment == 1) %>%
  select(tweet)

corpus <- Corpus(VectorSource(negative_tweets$tweet))
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removeWords, stopwords("english"))
corpus <- tm_map(corpus, stripWhitespace)

wordcloud(corpus, max.words = 50)
```
```{r}
neutral_tweets <- twitter_data %>%
  filter(sentiment == 2) %>%
  select(tweet)

corpus <- Corpus(VectorSource(neutral_tweets$tweet))
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removeWords, stopwords("english"))
corpus <- tm_map(corpus, stripWhitespace)

wordcloud(corpus, max.words = 50)
```
# Train Naive Bayes
## Load the necessary libraries: 
Start by loading the required libraries for data manipulation, modeling, and evaluation.
```{r}
source("usePackages.R")
trainpkgnames <- c("tidyverse","tm","tidymodels")
loadPkgs(trainpkgnames)
# install.packages("cli")
# library(cli)
```

# Train naive Bayes model
## Load the necessary libraries: 
Start by loading the required libraries for data manipulation, modeling, and evaluation.
```{r}
source("usePackages.R")
trainpkgnames <- c("tidyverse","tm","caret")
loadPkgs(trainpkgnames)
```

```{r}
# Load the data from a csv file
tweets_data <- read_csv('../input/train1.csv')

tweets_data$sentiment <- tweets_data$sentiment - 1

# Create a Corpus from the text column
corpus <- Corpus(VectorSource(tweets_data$tweet))

# Clean and preprocess the Corpus
corpus <- tm_map(corpus, content_transformer(tolower))
corpus <- tm_map(corpus, removePunctuation)
corpus <- tm_map(corpus, removeNumbers)
corpus <- tm_map(corpus, removeWords, stopwords("en"))

# Define a control function to select a minimum word frequency
control <- list(wordLengths=c(1, Inf), bounds = list(global = c(5, Inf)))

# Create a Document-Term Matrix
dtm <- DocumentTermMatrix(corpus, control)

# Convert the Document-Term Matrix to a dataframe
dtm_df <- as.data.frame(as.matrix(dtm))

# Add sentiment as a column to the dataframe
dtm_df$sentiment <- as.factor(tweets_data$sentiment)
```

```{r}
# Split the data into training and testing sets
set.seed(123) 
train_indices <- sample(1:nrow(dtm_df), 0.8*nrow(dtm_df))
train_data <- dtm_df[train_indices, ]
test_data <- dtm_df[-train_indices, ]

# Check the balance of sentiment categories
print(table(train_data$sentiment))

# If the classes are imbalanced, we can do a simple resampling
# Here is a simple way to upsample the minority classes
up_train <- upSample(x = train_data[, -ncol(train_data)],
                     y = train_data$sentiment)
up_train$sentiment <- as.factor(up_train$Class)
```

```{r}
# Fit a Random Forest model to the training data
model <- train(sentiment ~ ., data = up_train, method = 'rf')
```

```{r}
# Use the model to predict sentiment on test data
test_data$predicted_sentiment <- predict(model, test_data)

# Check the accuracy on the test set
print(mean(test_data$sentiment == test_data$predicted_sentiment))
```

