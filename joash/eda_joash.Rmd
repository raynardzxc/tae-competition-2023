---
title: "Not Raynard's EDA Notebook"
output: html_notebook
---

Discrete Choice Model

# Import Libraries
```{r}
rm(list=ls())
# Execute our custom script for loading packages
source("usePackages.R")
# Name of the packages 
pkgnames <- c("caret","randomForest", "stats", "dplyr")
# Use our custom load function
loadPkgs(pkgnames)

# Set seed
seed <- 41
```

# Import Data
```{r}
safety <- read.csv("./train1_preprocessed.csv")
test <- read.csv("./test1_preprocessed.csv")
```

```{r}
#select_cols <- c("segmentind", "yearind", "milesind", "milesa", "nightind", "nighta", #"pparkind","genderind", "ageind", "agea","educind", "regionind", "Urbind", "incomeind", #"incomea")

#for (i in select_cols) {
#  result <- table(safety[[i]])
#  print(paste("Frequency table for", i))
#  print(result) # Check for 1s
#  print("-------------------------------")
#}
```

```{r}
safety <- subset(safety, select = -c(Case, No, Task, Ch1, Ch2, Ch3, Ch4, CC4, BU4, RP4, LD4, BZ4, FC4, PP4, KA4, SC4, TS4, NV4, Price4, SC3, MA2, FP1, FP3, FP2, SC2, MA3, NS3, NS1, NS2, BU1, BU2, BU3, Urbind, ageind, AF3, LD2, BZ2, CC3, TS2, BZ1, BZ3, PP2, AF1, LD3, LB3, LB2, LB1, MA1, SC1))

set.seed(seed)
trainingIndex <- createDataPartition(y = safety$Choice, times = 1, p = 0.8, list = FALSE)
trainingSet <- safety[trainingIndex,]
testSet <- safety[-trainingIndex,]

trainingSet$Choice <- as.factor(trainingSet$Choice)
```

```{r}
set.seed(seed)
model <- randomForest(Choice ~ ., 
                   data = trainingSet,
                   ntree = 500)

mtry <- tuneRF(trainingSet[1:ncol(trainingSet)-1],trainingSet$Choice, ntreeTry=500,
               stepFactor=1.5,improve=0.001, trace=TRUE, plot=TRUE)
best.m <- mtry[mtry[, 2] == min(mtry[, 2]), 1]
print(mtry)
print(best.m)
```
```{r}
set.seed(seed)
rf <-randomForest(Choice~.,data=trainingSet, mtry=best.m, importance=TRUE,ntree=500)
print(rf)
#Evaluate variable importance
importance(rf)
varImpPlot(rf)
```

```{r}
pred <- predict(rf, testSet, type="response")
testSet$Choice_pred <- pred
testSet$Choice_pred <- as.numeric(testSet$Choice_pred)
```

```{r}
cfn_table <- table(testSet$Choice, testSet$Choice_pred)
cfn_table
```
```{r}
acc <- sum(diag(cfn_table))/sum(cfn_table)
acc
```

```{r}
log_loss <- function(actual, predicted) {
  n <- length(actual)
  actual <- as.integer(actual) # Ensure actual values are integers
  predicted <- as.integer(predicted) # Ensure predicted values are integers

  # Convert actual and predicted values to one-hot encoding
  actual_one_hot <- matrix(0, nrow = n, ncol = max(actual))
  predicted_one_hot <- matrix(0, nrow = n, ncol = max(predicted))
  actual_one_hot[cbind(1:n, actual)] <- 1
  predicted_one_hot[cbind(1:n, predicted)] <- 1

  # Calculate log loss
  epsilon <- 1e-15 # Small value to avoid division by zero
  log_loss <- -sum(actual_one_hot * log(pmax(predicted_one_hot, epsilon))) / n
  return(log_loss)
}

loss <- log_loss(testSet$Choice, testSet$Choice_pred)
print(loss)
```

